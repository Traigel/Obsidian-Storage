2022-08-16 00:01
Tags: #JavaScript #this
__
# this
Свойство контекста выполнения кода (global, function или eval), которое в нестрогом режиме всегда является ссылкой на объект, а в строгом режиме может иметь любое значение.

1) Global context  
2) this внутки функции  
3) .bind .call .apply
4) Поведение this внутри конструктора
---
### 1) Global context
this в глобальном контексте - это всегда глабальный объект window
```js
console.log(this) //выведет объект window
```
---
### 2) this внутки функции
Мы не знаем что это за переменная, нужно знать откуда она вызывается.
Важен момент вызова, там и определяется каким будет this
Если this в обычной функции, всегда ищем место вызова этой функции, смотрим какой объект слева от точки, значит он и будет this. Если объекта нету то this будет глабальным объектом window
Если this в стреочной функции, от он всегда будет выпригивать во внешнее окнружение и там будет его искать
```js
const vladimir = {  
    name: 'Vladimir',  
    age: 28,  
    showName() {  
        console.log(this.name)  
    },  
    showAge: () => {  
        console.log(this.age)  
    }  
}

const alexandra = {  
    name: 'Alexandra',  
    showName: vladimir.showName  
}

vladimir.showName()     // this ---> vladimir  
alexandra.showName()    // this ---> alexandra

const showeName = vladimir.showName  
// В нестрогом режиме this будет undefined, но браузер дасть ему объект window

showeName()             // this ---> undefined ---> window
```
Стелочная функция всегда ищет this из внешнего лексического значяения, поднимается в верх и ищет объект

---
### 3) .bind .call .apply
Помогает не потерять контекст.
Если один метод сработал, то уже передеалть другим методом мы не сможет.
Не использовать в стрелочных функция, методы отрабатываются но не привязываются к контексту.
```js
function foo(a, b , c) {  
    console.log(this)  
}
```
`call` - вызывает функцию, с указанием this который мы хотим, и передаём аргументы которые нужны функции.
```js
foo.call({name: 'Vladimir'}, 1, 2, 3)
```
`apply` - тоже самое что и call, но методы передаются в массимве.
```js
foo.apply({name: 'Vladimir'}, [1, 2, 3])
```
`bind` - возвращает функцию в которой контекст уже привязан.
```js
const bindedF = foo2.bind({name: 'Vladimir'}, 1, 2, 3)  
bindedF()

//можно написать два вызов  
foo2.bind({name: 'Vladimir'}, 1, 2, 3)()
```
---
### 4) Поведение this внутри конструктора
this = {} это новый объект.
this внутри конструктора всегда новый экземпляр объекта.
- если из конструктора нечего не ретёрнится, по умолчанию возвращается this.
- если ретёрнится примитив, то конструктор всё ровно вернёт this.
- естли ретёрнится объект то он же и вернётся.
```js
function User(name) {  
    this.name = name  
}  
  
const vladimir1 = new User('Vladimir')
```

__
### Links
[[JavaScript]]