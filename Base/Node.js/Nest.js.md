2025-01-21 16:01
Tags: #nestjs

---

[Nest](https://docs.nestjs.com/) (NestJS) — это фреймворк для создания эффективных и масштабируемых серверных приложений [Node.js](https://nodejs.org/).

### Содержание:
- [Команды](#Команды)
- [Controllers](#Controllers)
- [Services](#Services)
- [Modules](#Modules)
- [Repositories](#Repositories)
- [Middleware (Промежуточное ПО)](#Middleware)
- [Pipes (Трубы)](#Pipes)
- [Guards (Охранники)](#Guards)
- [Interceptors (Перехватчики)](#Interceptors)

---

## Команды

| Команда                                        | Описание                                            |
| ---------------------------------------------- | --------------------------------------------------- |
| npm i -g @nestjs/cli<br>                       | Глобально устанавливаем команды nest (если их нету) |
| nest new [project-name]                        | Устанавливаем проект nest.js                        |
| npm i --save class-validator class-transformer | Пакеты валидации и трансформации DTO                |

| Команда                                 | Описание                                      |
| --------------------------------------- | --------------------------------------------- |
| nest g resource [module-name] --no-spec | Создать **полный** шаблон модуля (без тестов) |
| nest g controller [name]                | Создать шаблон контроллера                    |


---

## Controllers

Контроллеры отвечают за обработку входящих **запросов** и отправку **ответов** клиенту.

![[controllers_rest_1.png]]

Назначение контроллера — получать конкретные запросы для приложения. Механизм **маршрутизации** определяет, какой контроллер получает те или иные запросы. Часто у каждого контроллера есть несколько маршрутов, и разные маршруты могут выполнять разные действия.

```ts
import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```


---

## Services

Это классы, которые содержат бизнес-логику приложения.

```ts
import { Injectable } from '@nestjs/common';  
  
@Injectable()  
export class AppService {  
  getHello(): string {  
    return 'Hello World!';  
  }  
}
```

Сервисы обеспечивают разделение логики между контроллерами (которые обрабатывают запросы) и бизнес-слоем приложения, что способствует лучшей организации кода и облегчает тестирование.

---

## Modules

Модуль — это класс, аннотированный декоратором `@Module()`. Декоратор `@Module()`. предоставляет метаданные, которые **Nest** использует для организации структуры приложения.

![[modules_rast_1.png]]

В каждом приложении есть как минимум один модуль, **корневой модуль**. Корневой модуль — это отправная точка, которую Nest использует для построения **графа приложения** — внутренней структуры данных, которую Nest использует для определения взаимосвязей и зависимостей между модулями и поставщиками.

```typescript
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}
```


---

## Repositories

Термин **repository (репозиторий)** относится к паттерну проектирования, который обеспечивает абстракцию над операциями с базой данных. Репозиторий предоставляет интерфейс для взаимодействия с данными, отделяя логику доступа к данным от остальной бизнес-логики приложения.

---

## Middleware


это функция, которая вызывается **до** обработчика маршрута. Функции middleware имеют доступ к объектам `request` (запроса) и `response` (ответа), а также к `next()` функции middleware в цикле запроса-ответа приложения. **Следующая** функция middleware обычно обозначается переменной с именем `next`.

![[middleware_nest_1.png]]

---

## Pipes
Трубы (преобразование, проверка)

Pipes имеют два типичных варианта использования:
- **преобразование**: преобразуйте входные данные в нужную форму (например, из строки в целое число)
- **проверка**: оцените входные данные и, если они корректны, просто передайте их без изменений; в противном случае вызовите ошибку

Это класс, аннотированный декоратором `@Injectable()`, который реализует интерфейс `PipeTransform`.

![[pipes_rest_1.png]]

Чтобы использовать конвейер, нам нужно привязать экземпляр класса конвейера к соответствующему контексту. В нашем `ParseIntPipe` примере мы хотим связать конвейер с определённым методом обработчика маршрута и убедиться, что он запускается до вызова метода. Мы делаем это с помощью следующей конструкции, которую будем называть привязкой конвейера на уровне параметров метода:

```ts
@Post()
@UsePipes(new ZodValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

```ts
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

Это гарантирует, что выполняется одно из следующих двух условий: либо параметр, который мы получаем в методе `findOne()`, является числом (как и ожидалось при вызове `this.catsService.findOne()`), либо возникает исключение до вызова обработчика маршрута.

---

## Guards
Охранники

У guards **одна задача**. Они определяют, будет ли конкретный запрос обработан обработчиком маршрута или нет, в зависимости от определённых условий (например, разрешений, ролей, списков управления доступом и т. д.), присутствующих во время выполнения. Это часто называют **авторизацией**.

Это класс, аннотированный декоратором `@Injectable()`, который реализует интерфейс `CanActivate`.

![[guards_rest_1.png]]

```ts auth.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}
```

**Aвторизация** — отличный вариант использования Guards, поскольку определённые маршруты должны быть доступны только в том случае, если у вызывающего абонента (обычно это конкретный авторизованный пользователь) есть достаточные разрешения.

Ниже мы настроили guard, привязанного к контроллеру, с помощью декоратора `@UseGuards()`

```ts
@Controller('cats')
@UseGuards(AuthGuard)
export class CatsController {}
```

---

## Interceptors
Перехватчики

Interceptors обладают набором полезных функций, основанных на методе [аспектно-ориентированного программирования](https://en.wikipedia.org/wiki/Aspect-oriented_programming) (AOP). Они позволяют:

- привязать дополнительную логику до / после выполнения метода
- преобразовать результат, возвращаемый функцией
- преобразовать исключение, генерируемое функцией
- расширить базовое поведение функции
- полностью переопределить функцию в зависимости от конкретных условий (например, для целей кэширования)

![[interceptors_rest_1.png]]

---
### Links
[[Node.js]]
