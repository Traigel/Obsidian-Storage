2022-07-19 15:17
Tags: #eventLoop

Это механизм, который позволяет JavaScript выполнять асинхронные операции, не блокируя основной поток выполнения.

Event Loop обрабатывает осинхронные события, и в порядке очереди отправляет их в стек вызова.

Начинает работать только когда стек пустой (выполнены синхронные запросы), после клодёт в Stack по одной задаче из очередей.
- Очереди Event Loop:
1) Микротаски - промисы
2) Очередь рендеров - HTML, CSS...
3) Макротаски - очередь колбеков

![[Event_Loop.png]]

---
### Как события добавляются в очередь
Все события в браузерах постоянно добавляются в очередь, если они произошли или имеют свой обработчик. setTimeout может добавлять событие в очередь не сразу, а по прошествии указанного времени. Если на данный момент в очереди нет событий, то оно поступит в обработку сразу.

Когда операция setTimeout обрабатывается в стеке, она отправляется соответствующему API, который ожидает до указанного времени, чтобы отправить эту операцию в обработку. Среда управляет несколькими параллельными циклами событий, например, для обработки вызовов API. Веб-воркеры также работают в собственном цикле событий.

**Операция отправляется в очередь событий. Следовательно, у нас есть циклическая схема для выполнения асинхронных операций в JavaScript. Сам язык является однопоточным, но API-интерфейсы браузера действуют как отдельные потоки**

Давайте посмотрим, как отложить выполнение функции до тех пор, пока стек не очистится.

Пример использования `setTimeout(() => {}), 0)` заключается в том, чтобы вызвать функцию, но выполнить ее после выполнения всех остальных функций в коде.

Пример:
```js
const bar = () => console.log('bar')
const baz = () => console.log('baz')
const foo = () => {
	console.log('foo')
	setTimeout(bar, 0)
	baz()
}
foo()
```
При запуске кода сначала вызывается foo(). Внутри foo() мы сначала вызываем setTimeout, передавая bar в качестве аргумента, и инструктируем его таким образом, чтобы он запускался как можно быстрее, передавая 0 в качестве таймера. Затем мы вызываем baz().

Порядок функций в программе:
![[iteration.png]]

---
### Очередь событий
При вызове setTimeout(), браузер или Node.js запускают таймер. По истечении таймера (в нашем случае мы установили 0) в качестве тайм-аута, функция обратного вызова помещается в очередь событий.

Очередь событий также является местом, где инициированные пользователем события (клики мышью, ввод с клавиатуры и др.) помещаются в очередь до того, как код сможет на них отреагировать.

Event Loop отдает приоритет стеку вызовов. Сначала он обрабатывает все, что находит в стеке вызовов, а когда там ничего не остается, переходит к обработке очереди событий.

**setTimeout с аргументом  0** не гарантирует, что обработка будет выполнена мгновенно. Все зависит от того, сколько задач в данный момент находится в очереди. В примере ниже ”message” будет выведена быстрее обработчика callback_1. Объясняется это тем, что задержка представляет собой минимальное время, необходимое среде на выполнение запроса.

```js
(function () {
	console.log('start');
	setTimeout(function callback() {
		console.log('message from callback');
	});
	console.log('message');
	setTimeout(function callback_1() {
		console.log('message from callback_1');
	}, 0);
	console.log('finish');
})();

// "start"
// "message"
// "finish"
// "message from callback"
// "message from callback_1"
```

Цикл событий в JavaScript отличается от других языков тем, что его поток выполнения никогда не блокируется, кроме некоторых исключений, таких как alert или синхронный HTTP-запрос, которые не рекомендуется использовать. Поэтому даже когда приложение ожидает запросы из хранилища или ответ с сервера, оно может обрабатывать другие процессы, например пользовательский ввод.

---
### Links
[[Browser]]
[Филипп Робертс: Что за чертовщина такая event loop?](https://www.youtube.com/watch?v=8aGhZQkoFbQ)